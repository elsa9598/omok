<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>ê¹Œë¯¸ vs ê¹€ì¹˜: ìš´ëª…ì˜ ì˜¤ëª© í•œíŒ</title>
    <meta property="og:type" content="website">
    <meta property="og:title" content="ê¹Œë¯¸ vs ê¹€ì¹˜: ìš´ëª…ì˜ ì˜¤ëª© í•œíŒ">
    <meta property="og:description" content="í‘(ê¹Œë¯¸) vs ë°±(ê¹€ì¹˜)! ê³¼ì—° ìŠ¹ìëŠ”?">
    <meta property="og:image" content="kakao.jpg">
    <link rel="icon" href="kakao.jpg">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gamja+Flower&display=swap" rel="stylesheet">

    <style>
        /* --- ê¸°ë³¸ ì„¤ì • --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: white;
            font-family: 'Gamja Flower', cursive; /* í°íŠ¸ ë³€ê²½ */
            font-size: 1.7rem; /* í•œê¸€ì´ë¼ ì¡°ê¸ˆ ë” í‚¤ì›€ */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }

        /* --- ë ˆì´ì•„ì›ƒ --- */
        .game-container {
            display: flex;
            width: 100%;
            height: 100%;
            max-width: 1600px;
        }

        /* í”Œë ˆì´ì–´ í”„ë ˆì„ */
        .player-frame {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; 
            padding: 20px;
            background: #333;
            box-sizing: border-box;
            transition: all 0.3s;
            position: relative;
            z-index: 10;
        }

        /* --- ìƒë‹¨ í”„ë¡œí•„ ì˜ì—­ --- */
        .player-top-info {
            display: flex;
            align-items: center;
            width: 100%;
            height: 60px; 
            justify-content: flex-start;
            flex-direction: row; 
            text-align: left;
        }

        .mini-profile-img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #fff;
            object-fit: cover;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            margin-right: 15px; 
        }

        .mini-player-name {
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        /* ì¤‘ì•™ ë³´ë“œ í”„ë ˆì„ */
        .board-frame {
            flex: 2;
            position: relative;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border-left: 2px solid #555;
            border-right: 2px solid #555;
        }

        /* --- í•˜ë‹¨ ì •ë³´ ë°•ìŠ¤ --- */
        .player-info-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            width: 100%;
            height: auto;
            padding: 10px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid transparent;
            transition: all 0.3s ease;
            margin-bottom: 0; 
        }

        .full-body-img {
            width: 100%;
            max-height: 350px; 
            object-fit: contain;
            filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5));
            margin-bottom: 10px;
        }

        .score-badge {
            background: #444;
            padding: 5px 20px;
            border-radius: 20px;
            font-size: 1.5rem;
            color: #ffd700;
            font-weight: bold;
        }

        /* í„´ í‘œì‹œ íš¨ê³¼ */
        .active-turn .player-info-box {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: pulse-border 1.5s infinite;
        }
        
        @keyframes pulse-border {
            0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.7); }
            100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
        }

        /* --- ë³´ë“œ ì˜ì—­ --- */
        #game-zoom-layer {
            position: relative;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }

        #go-board {
            background: url('wood.jpg') no-repeat center center;
            background-size: cover;
            border: 15px solid #000;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            display: block;
        }

        /* --- ì˜¤ë²„ë ˆì´ (í™”ë©´ ë®ëŠ” UI) --- */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        .yellow-btn {
            background-color: #ffd700;
            color: #000;
            font-family: 'Gamja Flower', cursive;
            font-size: 2.8rem;
            font-weight: bold;
            padding: 15px 50px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .yellow-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.6);
        }

        .yellow-btn:active { transform: scale(0.95); }

        .coin-toss-btn {
            width: 150px; height: 150px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff, #ddd);
            border: 5px solid #ffd700;
            font-family: 'Gamja Flower', cursive;
            font-size: 2.2rem;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: float 2s infinite ease-in-out;
            overflow: hidden;
            color: #000;
            font-weight: bold;
        }
        
        .coin-toss-btn img { width: 100%; height: 100%; object-fit: cover; display: none; }
        .coin-toss-btn:hover { transform: scale(1.2) rotate(10deg); box-shadow: 0 0 30px #ffd700; }

        .ceremony-content { text-align: center; animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .ceremony-img { max-width: 300px; max-height: 300px; filter: drop-shadow(0 0 20px rgba(255,255,255,0.5)); }
        .ceremony-text {
            font-size: 4.5rem; color: #ffd700;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            margin-top: 20px; font-family: 'Gamja Flower', cursive;
        }

        /* ìµœì¢… ìŠ¹ë¦¬ í™”ë©´ */
        .final-win-img {
            max-width: 80%;
            max-height: 60vh;
            border-radius: 20px;
            border: 5px solid #ffd700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            margin-bottom: 20px;
        }

        @keyframes popUp { 0% { transform: scale(0); opacity: 0; } 80% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        .control-btn {
            position: absolute; bottom: 20px; right: 20px;
            width: 60px; height: 60px;
            background: #ffd700; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            cursor: pointer; z-index: 90; font-size: 24px;
        }

        /* ëª¨ë°”ì¼ ë°˜ì‘í˜• */
        @media (max-width: 768px) {
            .game-container { flex-direction: column; }
            .player-frame {
                flex-direction: row; 
                flex: 0 0 80px;
                padding: 5px 10px;
                justify-content: space-between; 
            }
            .player-top-info {
                width: auto; height: 100%;
                justify-content: flex-start; 
            }
            .mini-player-name { font-size: 1.4rem; margin: 0 5px; }
            .mini-profile-img { width: 40px; height: 40px; margin-right: 10px; }
            
            .player-info-box {
                width: auto; padding: 5px; margin: 0;
                flex-direction: row; border: 2px solid transparent;
            }
            .full-body-img { display: none; } 
            .score-badge { font-size: 1.3rem; padding: 2px 10px; }
            
            .board-frame { flex: 1; border: none; }
            #go-board { border-width: 5px; }
            .ceremony-img { max-width: 200px; }
            .ceremony-text { font-size: 3.5rem; }
            .final-win-img { max-width: 90%; }
        }

    </style>
</head>
<body>

<div class="game-container">
    <div class="player-frame left" id="frame-p1">
        
        <div class="player-top-info">
            <img src="black_ggami.png" alt="Ggami Profile" class="mini-profile-img">
            <div class="mini-player-name">ê¹Œë¯¸ (ë‚˜)</div>
        </div>

        <div class="player-info-box">
            <img src="ggami_2.png" alt="Ggami Full Body" class="full-body-img">
            <div class="score-badge" id="score-p1">0 ìŠ¹</div>
        </div>
    </div>

    <div class="board-frame" id="board-container">
        
        <div id="game-zoom-layer">
            <canvas id="go-board" width="600" height="600"></canvas>
        </div>

        <div id="start-screen" class="overlay-screen">
            <h1 style="font-size: 5rem; margin-bottom: 20px; text-shadow: 2px 2px 4px #000;">ê¹Œë¯¸ vs ê¹€ì¹˜</h1>
            <button class="yellow-btn" onclick="showCoinToss()">ê²Œì„ ì‹œì‘</button>
        </div>

        <div id="toss-screen" class="overlay-screen hidden">
            <h2 style="margin-bottom: 30px; font-size: 3.5rem;">ìš´ëª…ì˜ ì„ íƒ</h2>
            <div class="coin-toss-btn" id="coin-btn" onclick="decideFirstTurn()">
                <span>í„°ì¹˜!</span>
                <img id="toss-result-img" src="" alt="Result">
            </div>
            <p id="toss-msg" style="margin-top: 20px; font-size: 1.8rem;">í„°ì¹˜í•´ì„œ ì„ ê³µì„ ì •í•˜ì„¸ìš”!</p>
        </div>

        <div id="ceremony-screen" class="overlay-screen hidden">
            <div class="ceremony-content">
                <img id="ceremony-img" src="" class="ceremony-img">
                <div id="ceremony-text" class="ceremony-text"></div>
            </div>
        </div>

        <div id="final-win-screen" class="overlay-screen hidden">
            <div class="ceremony-content">
                <img src="sangkim.png" class="final-win-img" alt="Final Winner">
                <div id="final-win-text" class="ceremony-text" style="color: #ffd700;"></div>
            </div>
        </div>
        
        <div class="control-btn" onclick="toggleFullscreenAndReset()">
            ğŸ”„
        </div>
    </div>

    <div class="player-frame right" id="frame-p2">
        
        <div class="player-top-info">
            <img src="white_kimchi.png" alt="Kimchi Profile" class="mini-profile-img">
            <div class="mini-player-name">ê¹€ì¹˜ (AI)</div>
        </div>

        <div class="player-info-box">
            <img src="kimchi_3.png" alt="Kimchi Full Body" class="full-body-img">
            <div class="score-badge" id="score-p2">0 ìŠ¹</div>
        </div>
    </div>
</div>

<script>
    /* --- ë³€ìˆ˜ ì„¤ì • --- */
    const canvas = document.getElementById('go-board');
    const ctx = canvas.getContext('2d');
    const zoomLayer = document.getElementById('game-zoom-layer');
    
    // ê²Œì„ ì„¤ì •
    const GRID_SIZE = 15;
    const CELL_SIZE = 40;
    const PADDING = 20;
    const BOARD_PIXEL_SIZE = CELL_SIZE * (GRID_SIZE - 1) + PADDING * 2;

    // í”Œë ˆì´ì–´ ID
    const HUMAN = 1; // ê¹Œë¯¸ (í‘)
    const AI = 2;    // ê¹€ì¹˜ (ë°±)

    // ìƒíƒœ ë³€ìˆ˜
    let board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let currentPlayer = 1;
    let gameActive = false;
    let round = 1;
    let scores = { 1: 0, 2: 0 };
    let winnerOfLastRound = 0;

    // ì´ë¯¸ì§€ ë¡œë“œ
    const imgBlack = new Image(); imgBlack.src = 'black_ggami.png';
    const imgWhite = new Image(); imgWhite.src = 'white_kimchi.png';
    
    // ì¤Œ/íŒ¬ ë³€ìˆ˜
    let scale = 1;
    let panX = 0; let panY = 0;
    let lastTouchX = 0; let lastTouchY = 0; let lastDist = 0;

    /* --- ì´ˆê¸°í™” --- */
    function initCanvas() {
        canvas.width = BOARD_PIXEL_SIZE;
        canvas.height = BOARD_PIXEL_SIZE;
        drawBoard();
    }

    imgBlack.onload = drawBoard;
    imgWhite.onload = drawBoard;

    /* --- ê²Œì„ ë¡œì§ --- */
    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ê²©ì ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;

        for (let i = 0; i < GRID_SIZE; i++) {
            ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
            ctx.lineTo(PADDING + (GRID_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE);
            ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
            ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (GRID_SIZE - 1) * CELL_SIZE);
        }
        ctx.stroke();

        // í™”ì  ê·¸ë¦¬ê¸°
        const stars = [3, 7, 11];
        ctx.fillStyle = "#000";
        for (let r of stars) {
            for (let c of stars) {
                ctx.beginPath();
                ctx.arc(PADDING + r * CELL_SIZE, PADDING + c * CELL_SIZE, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ëŒ ê·¸ë¦¬ê¸°
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (board[y][x] > 0) {
                    drawStone(x, y, board[y][x]);
                }
            }
        }
    }

    function drawStone(x, y, player) {
        const cx = PADDING + x * CELL_SIZE;
        const cy = PADDING + y * CELL_SIZE;
        const radius = CELL_SIZE / 2 - 2;
        const img = player === 1 ? imgBlack : imgWhite;

        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.clip();
        ctx.drawImage(img, cx - radius, cy - radius, radius * 2, radius * 2);
        
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
    }

    function updateTurnUI() {
        const frameP1 = document.getElementById('frame-p1');
        const frameP2 = document.getElementById('frame-p2');

        if (currentPlayer === HUMAN) {
            frameP1.classList.add('active-turn');
            frameP2.classList.remove('active-turn');
        } else {
            frameP1.classList.remove('active-turn');
            frameP2.classList.add('active-turn');
        }
    }

    function showCoinToss() {
        document.getElementById('start-screen').classList.add('hidden');
        if (round === 1) {
            document.getElementById('toss-screen').classList.remove('hidden');
        } else {
            startRound(winnerOfLastRound === 0 ? 1 : winnerOfLastRound); 
        }
    }

    function decideFirstTurn() {
        const btn = document.getElementById('coin-btn');
        const img = document.getElementById('toss-result-img');
        const msg = document.getElementById('toss-msg');
        
        const rand = Math.floor(Math.random() * 2) + 1; // 1 or 2
        
        btn.style.animation = 'none';
        btn.style.transform = 'scale(1.5) rotate(360deg)';
        
        const resultImgSrc = rand === 1 ? 'black_ggami.png' : 'white_kimchi.png';
        const resultName = rand === 1 ? "ê¹Œë¯¸ (ë‚˜)" : "ê¹€ì¹˜ (AI)";
        
        img.src = resultImgSrc;
        img.style.display = 'block';
        document.querySelector('#coin-btn span').style.display = 'none';
        
        msg.innerText = `${resultName} ì„ ê³µ!`;
        msg.style.color = '#ffd700';

        setTimeout(() => {
            document.getElementById('toss-screen').classList.add('hidden');
            startRound(rand);
        }, 1500);
    }

    function startRound(startPlayer) {
        currentPlayer = startPlayer;
        gameActive = true;
        updateTurnUI();

        // AIê°€ ì„ ê³µì´ë©´ AI ì´ë™ íŠ¸ë¦¬ê±°
        if (currentPlayer === AI) {
            setTimeout(makeAiMove, 1000);
        }
    }

    canvas.addEventListener('click', (e) => {
        // ê²Œì„ ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜ AI í„´ì´ë©´ í´ë¦­ ë¬´ì‹œ
        if (!gameActive || currentPlayer === AI) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const clickX = (e.clientX - rect.left) * scaleX;
        const clickY = (e.clientY - rect.top) * scaleY;

        const gx = Math.round((clickX - PADDING) / CELL_SIZE);
        const gy = Math.round((clickY - PADDING) / CELL_SIZE);

        placeStone(gx, gy);
    });

    // ----------------------------------------------------
    // --- ê°•ë ¥í•´ì§„ AI ë¡œì§ (High Intelligence) ---
    // ----------------------------------------------------
    
    function makeAiMove() {
        if (!gameActive) return;

        // 1. ìµœì ì˜ ìˆ˜ ê³„ì‚°
        let bestMove = getBestMove(AI);

        // 2. ëŒ ë‘ê¸° (1000ms ë”œë ˆì´ ìœ ì§€)
        if (bestMove) {
            placeStone(bestMove.x, bestMove.y);
        }
    }

    function getBestMove(player) {
        const opponent = player === AI ? HUMAN : AI;
        let bestScore = -Infinity;
        let bestMoves = [];

        // ì „ì²´ ë³´ë“œ ìŠ¤ìº”
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (board[y][x] === 0) {
                    
                    // AI 3-3 ì²´í¬ (AIëŠ” ë˜‘ë˜‘í•˜ê²Œ ê¸ˆìˆ˜ë¥¼ í”¼í•¨)
                    // if (player === HUMAN && check33(x, y, player)) continue; 

                    // ì ìˆ˜ ê³„ì‚°
                    let attackScore = evaluatePoint(x, y, player); // AI ê³µê²© ì ìˆ˜
                    let defenseScore = evaluatePoint(x, y, opponent); // ì‚¬ìš©ì ë°©ì–´ ì ìˆ˜

                    // ê°€ì¤‘ì¹˜: ìƒëŒ€ë°©ì´ ì´ê¸°ë ¤ í•  ë•Œ ë°©ì–´í•˜ëŠ” ê²ƒì´ ê³µê²©ë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ìŒ (1.2ë°°)
                    let totalScore = attackScore + (defenseScore * 1.2);

                    // ì¦‰ì‹œ ìŠ¹ë¦¬ ê°€ëŠ¥í•œ ìë¦¬ (ìµœìš°ì„ )
                    if (attackScore >= 100000) totalScore = 2000000; 
                    // ì¦‰ì‹œ íŒ¨ë°° ë§‰ì•„ì•¼ í•˜ëŠ” ìë¦¬ (ì°¨ì„ )
                    else if (defenseScore >= 100000) totalScore = 1000000;

                    // ì˜¤í”„ë‹ ë‹¤ì–‘ì„±ì„ ìœ„í•œ ì•½ê°„ì˜ ëœë¤ì„±
                    totalScore += Math.random() * 5;

                    if (totalScore > bestScore) {
                        bestScore = totalScore;
                        bestMoves = [{x, y}];
                    } else if (totalScore === bestScore) {
                        bestMoves.push({x, y});
                    }
                }
            }
        }

        // ì‹œì‘ ì‹œ ì¤‘ì•™ì´ ë¹„ì–´ìˆìœ¼ë©´ ì„ ì  (ì •ì„)
        const center = Math.floor(GRID_SIZE / 2);
        if (board[center][center] === 0 && bestScore < 100) {
            return {x: center, y: center};
        }

        return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : null;
    }

    // íŒ¨í„´ ì ìˆ˜ ê³„ì‚° í•¨ìˆ˜
    function evaluatePoint(x, y, player) {
        let score = 0;
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]]; // ê°€ë¡œ, ì„¸ë¡œ, ëŒ€ê°ì„ (\), ëŒ€ê°ì„ (/)

        for (let [dx, dy] of directions) {
            // (x,y)ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ë°˜ê²½ 4ì¹¸ì˜ íŒ¨í„´ ë¬¸ìì—´ ìƒì„±
            const lineStr = getLinePattern(x, y, dx, dy, player);
            score += getPatternScore(lineStr);
        }
        return score;
    }

    function getLinePattern(x, y, dx, dy, player) {
        let str = "";
        // ì•ë’¤ë¡œ 4ì¹¸ì”© ê²€ì‚¬
        for (let i = -4; i <= 4; i++) {
            if (i === 0) {
                str += "M"; // Me (í˜„ì¬ ë‘ë ¤ëŠ” ìœ„ì¹˜)
            } else {
                const nx = x + dx * i;
                const ny = y + dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
                    str += "X"; // ë²½/ê°€ì¥ìë¦¬
                } else {
                    const cell = board[ny][nx];
                    if (cell === player) str += "P"; // ë‚´ ëŒ
                    else if (cell === 0) str += "0"; // ë¹ˆì¹¸
                    else str += "E"; // ì  ëŒ
                }
            }
        }
        return str;
    }

    function getPatternScore(str) {
        let score = 0;

        // --- 5ëª© ì™„ì„± (ìŠ¹ë¦¬) ---
        // PPPPM, MPPPP, PPMPP ë“±
        if (/P{4}M|MP{4}|P{3}MP|PMP{3}|P{2}MP{2}/.test(str)) return 100000;

        // --- ì—´ë¦° 4 (ë§‰ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒ í„´ ìŠ¹ë¦¬) ---
        // 0PPPPM0, 0MPPPP0 ë“±
        if (/0P{3}M0|0MP{3}0|0P{2}MP0|0PMP{2}0/.test(str)) return 50000;

        // --- ë‹«íŒ 4 / ë¹ˆì¹¸ ë‚€ 4 (ì¦‰ì‹œ ë§‰ì•„ì•¼ í•¨) ---
        // PPPP0, 0PPPP, P0PPP, PP0PP 
        if (/P{3}M|MP{3}|P{2}MP|PMP{2}/.test(str)) return 10000; 
        if (/P{2}0MP|PM0P{2}|P0PMP|PMP0P/.test(str)) return 8000; // ë¹ˆì¹¸ 4 (ê°•ë ¥í•¨)

        // --- ì—´ë¦° 3 (ê³µê²© ê¸°íšŒ) ---
        // 00PPM00, 00MPP00, 0PMP0
        if (/0P{2}M0|0MP{2}0|0PMP0/.test(str)) return 5000;

        // --- ë¹ˆì¹¸ ë‚€ 3 (í•¨ì •ìˆ˜) ---
        // 0P0PM0, 0M0PP0 ë“± (ëŒ€ê°ì„  ê³µê²©ì—ì„œ ìì£¼ ë°œìƒ)
        if (/0P0PM0|0MP0P0|0P0MP0/.test(str)) return 4500;

        // --- ì—´ë¦° 2 ---
        if (/00PM00|00MP00|0P0M0/.test(str)) return 500;

        return score;
    }

    // ----------------------------------------------------
    // --- AI ë¡œì§ ë ---
    // ----------------------------------------------------

    // --- 3-3 ê¸ˆìˆ˜ ë¡œì§ (ì‚¬ëŒë§Œ í•´ë‹¹) ---
    function check33(x, y, player) {
        board[y][x] = player; 
        let openThreeCount = 0;
        const directions = [[1,0], [0,1], [1,1], [1,-1]]; 

        for(let d of directions) {
            if(isDirectionOpenThree(x, y, player, d[0], d[1])) {
                openThreeCount++;
            }
        }
        board[y][x] = 0; // ì›ìƒë³µêµ¬
        return openThreeCount >= 2;
    }

    function isDirectionOpenThree(x, y, player, dx, dy) {
        let str = "";
        for (let i = -4; i <= 4; i++) {
            let nx = x + dx * i;
            let ny = y + dy * i;
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) str += "X"; 
            else {
                if (board[ny][nx] === player) str += "P";
                else if (board[ny][nx] === 0) str += "0";
                else str += "E"; 
            }
        }
        // ê¸ˆìˆ˜ ì¡°ê±´: ì–‘ìª½ì´ ëš«ë¦° 3
        if (str.includes("0PPP0")) return true;
        if (str.includes("0P0PP0")) return true;
        if (str.includes("0PP0P0")) return true;
        return false;
    }

    function placeStone(x, y) {
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
        if (board[y][x] !== 0) return;

        // 3-3 ì²´í¬ (ì‚¬ëŒì¼ ë•Œë§Œ ê²½ê³ )
        if(currentPlayer === HUMAN && check33(x, y, currentPlayer)) {
            alert("í‘ëŒì€ 3-3(ìŒì‚¼) ê¸ˆìˆ˜ì…ë‹ˆë‹¤!");
            return; 
        }

        board[y][x] = currentPlayer;
        
        animatePlacement(x, y, currentPlayer);
        drawBoard();

        if (checkWin(x, y, currentPlayer)) {
            handleWin(currentPlayer);
        } else {
            // í„´ ë³€ê²½
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnUI();

            // ë‹¤ìŒì´ AIë©´ ë”œë ˆì´ í›„ ì‹¤í–‰
            if (gameActive && currentPlayer === AI) {
                setTimeout(makeAiMove, 1000); 
            }
        }
    }

    function animatePlacement(x, y, player) {
        const overlay = document.createElement('img');
        overlay.src = player === 1 ? 'black_ggami.png' : 'white_kimchi.png';
        overlay.style.position = 'absolute';
        overlay.style.width = (CELL_SIZE * 2) + 'px';
        overlay.style.height = (CELL_SIZE * 2) + 'px';
        overlay.style.borderRadius = '50%';
        overlay.style.left = (PADDING + x * CELL_SIZE - CELL_SIZE + CELL_SIZE/2) + 'px'; 
        overlay.style.top = (PADDING + y * CELL_SIZE - CELL_SIZE + CELL_SIZE/2) + 'px';
        overlay.style.transition = 'all 0.3s ease-out';
        overlay.style.opacity = '0.8';
        overlay.style.pointerEvents = 'none';

        zoomLayer.appendChild(overlay);

        requestAnimationFrame(() => {
            overlay.style.transform = 'scale(1)'; 
        });
        
        setTimeout(() => {
            overlay.remove();
        }, 300);
    }

    function checkWin(x, y, player) {
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

        for (let [dx, dy] of directions) {
            let count = 1;
            for (let i = 1; i < 5; i++) {
                const nx = x + dx * i;
                const ny = y + dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
                if (board[ny][nx] === player) count++;
                else break;
            }
            for (let i = 1; i < 5; i++) {
                const nx = x - dx * i;
                const ny = y - dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
                if (board[ny][nx] === player) count++;
                else break;
            }
            if (count >= 5) return true;
        }
        return false;
    }

    function handleWin(winner) {
        gameActive = false;
        scores[winner]++;
        winnerOfLastRound = winner;
        
        document.getElementById(`score-p${winner}`).innerText = `${scores[winner]} ìŠ¹`;

        if (scores[winner] >= 2) {
            const finalScreen = document.getElementById('final-win-screen');
            const finalText = document.getElementById('final-win-text');
            const winnerName = winner === HUMAN ? "ê¹Œë¯¸" : "ê¹€ì¹˜";
            
            finalText.innerText = `${winnerName} ìµœì¢… ìš°ìŠ¹!!!`;
            finalScreen.classList.remove('hidden');

            setTimeout(() => {
                finalScreen.classList.add('hidden');
                alert(`ìµœì¢… ìš°ìŠ¹: ${winnerName}! ì¶•í•˜í•©ë‹ˆë‹¤!`);
                location.reload();
            }, 3000);

        } else {
            const screen = document.getElementById('ceremony-screen');
            const img = document.getElementById('ceremony-img');
            const txt = document.getElementById('ceremony-text');

            screen.classList.remove('hidden');
            
            if (winner === HUMAN) { 
                img.src = 'ggam-5.png'; 
                txt.innerText = "ì•„ì‹¸!";
            } else { 
                img.src = 'kimchi-o2.png'; 
                txt.innerText = "í›—, ë‹¹ì—°í•˜ì§€!";
            }

            setTimeout(() => {
                screen.classList.add('hidden');
                round++;
                resetBoard();
                showCoinToss(); 
            }, 3000);
        }
    }

    function resetBoard() {
        board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        drawBoard();
    }

    /* --- ì¤Œ & íŒ¬ (Zoom & Pan) --- */
    const container = document.getElementById('board-container');
    container.addEventListener('touchstart', handleTouchStart, {passive: false});
    container.addEventListener('touchmove', handleTouchMove, {passive: false});
    container.addEventListener('touchend', handleTouchEnd);

    function handleTouchStart(e) {
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastDist = Math.hypot(dx, dy);
        } else if (e.touches.length === 1 && scale > 1) {
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const factor = dist / lastDist;
            let newScale = scale * factor;
            newScale = Math.max(1, Math.min(newScale, 3)); 
            scale = newScale;
            lastDist = dist;
            updateTransform();
        } else if (e.touches.length === 1 && scale > 1) {
            const dx = e.touches[0].clientX - lastTouchX;
            const dy = e.touches[0].clientY - lastTouchY;
            panX += dx; panY += dy;
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
            limitPan();
            updateTransform();
        }
    }

    function handleTouchEnd(e) {}
    function limitPan() {
        const maxPan = (scale - 1) * (BOARD_PIXEL_SIZE / 2);
        panX = Math.max(-maxPan, Math.min(maxPan, panX));
        panY = Math.max(-maxPan, Math.min(maxPan, panY));
    }
    function updateTransform() {
        zoomLayer.style.transform = `scale(${scale}) translate(${panX / scale}px, ${panY / scale}px)`;
    }
    function toggleFullscreenAndReset() {
        if (scale > 1) {
            scale = 1; panX = 0; panY = 0; updateTransform(); return; 
        }
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => console.log(err));
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    }

    initCanvas();
</script>
</body>
</html>