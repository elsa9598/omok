<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>ì²œí•˜ë¬´ì ì˜ ê¹€ì¹˜ì™€ì˜¤ëª© (3-3 ê¸ˆìˆ˜í¬í•¨)</title>
    
    <style>
        /* --- í°íŠ¸ ì„ ì–¸ --- */
        @font-face {
            font-family: 'Radio';
            src: url('radio.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        /* --- ê¸°ë³¸ ì„¤ì • --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: white;
            font-family: 'Radio', cursive, sans-serif;
            font-size: 1.7rem;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh; 
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- ë ˆì´ì•„ì›ƒ --- */
        .game-container {
            display: flex;
            width: 100%;
            height: 100%;
            max-width: 100%;
        }

        /* í”Œë ˆì´ì–´ í”„ë ˆì„ */
        .player-frame {
            flex: 0 0 20%; 
            min-width: 160px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; 
            padding: 40px 10px;
            background: #333;
            box-sizing: border-box;
            transition: all 0.3s;
            position: relative;
            z-index: 10;
        }

        /* --- ìƒë‹¨ í”„ë¡œí•„ ì˜ì—­ --- */
        .player-top-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-bottom: 20px;
            text-align: center;
        }

        .mini-profile-img {
            width: 10vw; 
            height: 10vw;
            max-width: 120px;
            max-height: 120px;
            min-width: 80px;
            min-height: 80px;
            border-radius: 50%;
            border: 4px solid #fff;
            object-fit: cover;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .mini-player-name {
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            margin-top: 10px;
            word-break: keep-all;
        }

        .score-badge {
            background: #444;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 1.6rem;
            color: #ffd700;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            margin-bottom: 5px;
        }

        /* --- ë‹¤ì‹œ(Undo) ë²„íŠ¼ ìŠ¤íƒ€ì¼ --- */
        .undo-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #ffd700;
            border: 3px solid #fff;
            color: #000;
            font-family: 'Radio', cursive, sans-serif;
            font-size: 1.6rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            margin-top: 15px;
            transition: transform 0.2s, background 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        .undo-btn:hover {
            transform: scale(1.1);
            background: #ffed4a;
        }
        
        .undo-btn:active {
            transform: scale(0.95);
        }

        /* --- í„´ í‘œì‹œ íš¨ê³¼ --- */
        .active-turn .mini-profile-img {
            border-color: #ffd700;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
            animation: profile-twinkle 1s infinite alternate;
        }

        @keyframes profile-twinkle {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.1); opacity: 0.8; box-shadow: 0 0 60px rgba(255, 215, 0, 1); }
        }

        /* --- ì¤‘ì•™ ë³´ë“œ í”„ë ˆì„ --- */
        .board-frame {
            flex: 1;
            position: relative;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; 
            padding: 0;
            min-width: 0;
        }

        .player-info-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: auto;
            background: transparent;
            border: none;
            margin-top: auto;
            padding-bottom: 30px;
        }

        /* --- ë³´ë“œ ì˜ì—­ --- */
        #game-zoom-layer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transform-origin: center center; 
            will-change: transform;
        }

        #go-board {
            background: url('wood.jpg') no-repeat center center;
            background-size: cover;
            border: none;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            display: block;
            max-width: 95%;
            max-height: 95%;
            width: auto;
            height: auto;
            aspect-ratio: 1 / 1; 
        }

        /* --- ê²½ê³  ë©”ì‹œì§€ (3-3 ê¸ˆìˆ˜) --- */
        #warning-toast {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 2rem;
            font-weight: bold;
            z-index: 200;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            border: 3px solid #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #warning-toast.show {
            opacity: 1;
            animation: shake 0.3s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%); }
            25% { transform: translate(-55%, -50%); }
            75% { transform: translate(-45%, -50%); }
        }

        /* --- ì˜¤ë²„ë ˆì´ (í™”ë©´ ë®ëŠ” UI) --- */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        .yellow-btn {
            background-color: #ffd700;
            color: #000;
            font-family: 'Radio', cursive, sans-serif;
            font-size: 2.8rem;
            font-weight: bold;
            padding: 15px 50px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .yellow-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.6);
        }

        .yellow-btn:active { transform: scale(0.95); }

        .coin-toss-btn {
            width: 150px; height: 150px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff, #ddd);
            border: 5px solid #ffd700;
            font-family: 'Radio', cursive, sans-serif;
            font-size: 2.2rem;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: float 2s infinite ease-in-out;
            overflow: hidden;
            color: #000;
            font-weight: bold;
        }
        
        .coin-toss-btn img { width: 100%; height: 100%; object-fit: cover; display: none; }
        .coin-toss-btn:hover { transform: scale(1.2) rotate(10deg); box-shadow: 0 0 30px #ffd700; }

        .ceremony-content { text-align: center; animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .ceremony-img { max-width: 300px; max-height: 300px; filter: drop-shadow(0 0 20px rgba(255,255,255,0.5)); }
        .ceremony-text {
            font-size: 4.5rem; color: #ffd700;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            margin-top: 20px; 
            font-family: 'Radio', cursive, sans-serif;
        }

        .final-win-img {
            max-width: 80%;
            max-height: 60vh;
            border-radius: 20px;
            border: 5px solid #ffd700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            margin-bottom: 20px;
        }

        @keyframes popUp { 0% { transform: scale(0); opacity: 0; } 80% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        /* --- ë°˜ì‘í˜• ë¯¸ë””ì–´ ì¿¼ë¦¬ --- */

        /* íƒœë¸”ë¦¿ */
        @media (max-width: 1024px) {
            .mini-player-name { font-size: 2.0rem; }
            .player-frame { min-width: 120px; padding: 20px 5px; }
        }

        /* ëª¨ë°”ì¼ (í° ì„¸ë¡œ ëª¨ë“œ) */
        @media (max-width: 768px) {
            .game-container { flex-direction: column; }
            .player-frame {
                flex: 0 0 auto; 
                width: 100%;
                height: 90px; 
                flex-direction: row; 
                padding: 0 15px;
                justify-content: space-between; 
                align-items: center;
                min-width: 0;
            }
            .player-top-info {
                width: auto; height: 100%;
                margin-bottom: 0;
                flex-direction: row;
                justify-content: flex-start; 
                align-items: center;
            }
            .mini-player-name { font-size: 1.8rem; margin: 0 10px; order: 2; }
            .mini-profile-img { width: 60px; height: 60px; min-width: 60px; min-height: 60px; margin-right: 10px; margin-bottom: 0; order: 1; }
            .score-badge { margin: 0; margin-left: auto; order: 3; font-size: 1.5rem; }
            
            .undo-btn {
                width: 50px; height: 50px; font-size: 1.3rem; margin-top: 0; margin-left: 10px; order: 4;
            }

            .player-info-box { display: none; }
            
            .board-frame { flex: 1; border: none; }
            #go-board { width: 95vw; height: 95vw; max-width: none; max-height: none; } 
            
            .ceremony-img { max-width: 200px; }
            .ceremony-text { font-size: 3.5rem; }
            .final-win-img { max-width: 90%; }
            #warning-toast { font-size: 1.5rem; width: 80%; text-align: center; }
        }

    </style>
</head>
<body>

<div class="game-container">
    <div class="player-frame left" id="frame-p1">
        
        <div class="player-top-info">
            <img src="black_ggami.png" alt="Ggami Profile" class="mini-profile-img">
            <div class="score-badge" id="score-p1">0 ìŠ¹</div> 
            <div class="mini-player-name">ê¹Œë¯¸ (ë‚˜)</div>
            <button class="undo-btn" id="undo-btn" onclick="undoLastTurn()">ë‹¤ì‹œ</button>
        </div>

        <div class="player-info-box"></div>
    </div>

    <div class="board-frame" id="board-container">
        
        <div id="game-zoom-layer">
            <canvas id="go-board"></canvas>
        </div>

        <div id="warning-toast">ğŸš« 3-3 ê¸ˆìˆ˜ì…ë‹ˆë‹¤!</div>

        <div id="start-screen" class="overlay-screen">
            <h1 style="font-size: 5rem; margin-bottom: 20px; text-shadow: 2px 2px 4px #000;">ê¹Œë¯¸(ë‚˜) vs ê¹€ì¹˜(ë°±)</h1>
            <button class="yellow-btn" onclick="handleStartGame()">ì˜¤ëª© 3íŒ2ìŠ¹ ì‹œì‘</button>
        </div>

        <div id="toss-screen" class="overlay-screen hidden">
            <h2 style="margin-bottom: 30px; font-size: 3.5rem;">ëˆ„ê°€ ë¨¼ì €í• ê¹Œ?</h2>
            <div class="coin-toss-btn" id="coin-btn" onclick="decideFirstTurn()">
                <span>í„°ì¹˜!</span>
                <img id="toss-result-img" src="" alt="Result">
            </div>
            <p id="toss-msg" style="margin-top: 20px; font-size: 1.8rem;">í„°ì¹˜í•´ì„œ ì„ ê³µì„ ì •í•˜ì„¸ìš”!</p>
        </div>

        <div id="ceremony-screen" class="overlay-screen hidden">
            <div class="ceremony-content">
                <img id="ceremony-img" src="" class="ceremony-img">
                <div id="ceremony-text" class="ceremony-text"></div>
            </div>
        </div>

        <div id="final-win-screen" class="overlay-screen hidden">
            <div class="ceremony-content">
                <img id="final-win-img" src="" class="final-win-img" alt="Final Winner">
                <div id="final-win-text" class="ceremony-text" style="color: #ffd700;"></div>
            </div>
        </div>
    </div>

    <div class="player-frame right" id="frame-p2">
        
        <div class="player-top-info">
            <img src="white_kimchi.png" alt="Kimchi Profile" class="mini-profile-img">
            <div class="score-badge" id="score-p2">0 ìŠ¹</div> <div class="mini-player-name">ê¹€ì¹˜ (ë°±)</div>
        </div>

        <div class="player-info-box"></div>
    </div>
</div>

<script>
    /* --- ì‚¬ìš´ë“œ ê°ì²´ ìƒì„± --- */
    const sndStart = new Audio('start.mp3');
    const sndBlack = new Audio('clack.mp3'); 
    const sndWhite = new Audio('clack_1.mp3'); 
    const sndRoundWin = new Audio('winbrass.mp3'); 
    const sndFinalWin = new Audio('fanfare.mp3'); 

    function playSound(sound) {
        if(sound) {
            sound.currentTime = 0; 
            sound.play().catch(e => console.log('Audio play failed:', e));
        }
    }

    /* --- ë³€ìˆ˜ ì„¤ì • --- */
    const canvas = document.getElementById('go-board');
    const ctx = canvas.getContext('2d');
    const zoomLayer = document.getElementById('game-zoom-layer');
    const boardContainer = document.getElementById('board-container'); 
    const warningToast = document.getElementById('warning-toast');
    
    // [19ì¤„ ë°”ë‘‘íŒ ì„¤ì •]
    const GRID_SIZE = 19; 
    const PADDING = 20;
    const CELL_SIZE = 40; 
    const BOARD_PIXEL_SIZE = CELL_SIZE * (GRID_SIZE - 1) + PADDING * 2;

    const HUMAN = 1; 
    const AI = 2;    

    let board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let moveHistory = []; 
    let currentPlayer = 1;
    let gameActive = false;
    let round = 1;
    let scores = { 1: 0, 2: 0 };
    let winnerOfLastRound = 0;

    // ë§ˆì§€ë§‰ ìˆ˜ í‘œì‹œìš©
    let lastMove = null;
    let blinkInterval = null;
    let blinkAlpha = 0.5;
    let blinkDir = 0.1;

    // ìŠ¹ë¦¬ ì‹œ ëŒ ê¹œë¹¡ì„(Red Blink)ìš©
    let winningStones = []; 
    let winBlinkState = false; 
    let winBlinkInterval = null;
    
    /* --- ì´ˆê¸°í™” --- */
    function initCanvas() {
        canvas.width = BOARD_PIXEL_SIZE;
        canvas.height = BOARD_PIXEL_SIZE;
        drawBoard();
    }

    /* --- ê²Œì„ ë¡œì§ --- */
    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ê²©ì ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;

        for (let i = 0; i < GRID_SIZE; i++) {
            ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
            ctx.lineTo(PADDING + (GRID_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE);
            ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
            ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (GRID_SIZE - 1) * CELL_SIZE);
        }
        ctx.stroke();

        // í™”ì 
        const stars = [3, 9, 15]; 
        ctx.fillStyle = "#000";
        for (let r of stars) {
            for (let c of stars) {
                ctx.beginPath();
                ctx.arc(PADDING + r * CELL_SIZE, PADDING + c * CELL_SIZE, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ëŒ ê·¸ë¦¬ê¸°
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (board[y][x] > 0) {
                    drawStone(x, y, board[y][x]);
                }
            }
        }

        // ë°±ëŒ(AI) ê¹œë¹¡ì„ (lastMove)
        if (lastMove && winningStones.length === 0) { 
            const cx = PADDING + lastMove.x * CELL_SIZE;
            const cy = PADDING + lastMove.y * CELL_SIZE;
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, CELL_SIZE * 0.48, 0, Math.PI * 2);
            ctx.lineWidth = 4;
            ctx.strokeStyle = `rgba(255, 215, 0, ${blinkAlpha})`; 
            ctx.stroke();
            ctx.restore();
        }
    }

    function drawStone(x, y, player) {
        const cx = PADDING + x * CELL_SIZE;
        const cy = PADDING + y * CELL_SIZE;
        const radius = CELL_SIZE * 0.48;

        let isWinningStone = false;
        if (winningStones.length > 0) {
            for(let ws of winningStones) {
                if(ws.x === x && ws.y === y) {
                    isWinningStone = true;
                    break;
                }
            }
        }

        ctx.save();
        ctx.shadowColor = "rgba(0, 0, 0, 0.4)";
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);

        if (player === 1) { 
            const grad = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.1, cx, cy, radius);
            grad.addColorStop(0, "#555");
            grad.addColorStop(0.3, "#222"); 
            grad.addColorStop(1, "#000");
            ctx.fillStyle = grad;
        } else { 
            const grad = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.1, cx, cy, radius);
            grad.addColorStop(0, "#fff");
            grad.addColorStop(0.9, "#ddd"); 
            grad.addColorStop(1, "#ccc");
            ctx.fillStyle = grad;
        }
        ctx.fill();

        if (isWinningStone && winBlinkState) {
            ctx.lineWidth = 5;
            ctx.strokeStyle = "#ff0000"; 
            ctx.shadowColor = "rgba(255, 0, 0, 0.8)";
            ctx.shadowBlur = 20;
            ctx.stroke();
        }

        ctx.restore();
    }

    function startBlinking(x, y) {
        if (blinkInterval) clearInterval(blinkInterval);
        
        lastMove = { x, y };
        blinkAlpha = 1.0; 
        blinkDir = -0.1;

        blinkInterval = setInterval(() => {
            blinkAlpha += blinkDir;
            if (blinkAlpha <= 0.2) blinkDir = 0.1;
            if (blinkAlpha >= 1.0) blinkDir = -0.1;
            if(winningStones.length === 0) drawBoard();
        }, 50);
    }

    function updateTurnUI() {
        const frameP1 = document.getElementById('frame-p1');
        const frameP2 = document.getElementById('frame-p2');

        if (currentPlayer === HUMAN) {
            frameP1.classList.add('active-turn');
            frameP2.classList.remove('active-turn');
        } else {
            frameP1.classList.remove('active-turn');
            frameP2.classList.add('active-turn');
        }
    }

    function handleStartGame() {
        playSound(sndStart);
        showCoinToss();
    }

    function showCoinToss() {
        document.getElementById('start-screen').classList.add('hidden');
        if (round === 1) {
            document.getElementById('toss-screen').classList.remove('hidden');
        } else {
            startRound(winnerOfLastRound === 0 ? 1 : winnerOfLastRound); 
        }
    }

    function decideFirstTurn() {
        const btn = document.getElementById('coin-btn');
        const img = document.getElementById('toss-result-img');
        const msg = document.getElementById('toss-msg');
        
        const rand = Math.floor(Math.random() * 2) + 1; 
        
        btn.style.animation = 'none';
        btn.style.transform = 'scale(1.5) rotate(360deg)';
        
        const resultImgSrc = rand === 1 ? 'black_ggami.png' : 'white_kimchi.png';
        const resultName = rand === 1 ? "ê¹Œë¯¸ (í‘:ë‚˜)" : "ê¹€ì¹˜(ë°±)";
        
        img.src = resultImgSrc;
        img.style.display = 'block';
        document.querySelector('#coin-btn span').style.display = 'none';
        
        msg.innerText = `${resultName} ì„ ê³µ!`;
        msg.style.color = '#ffd700';

        setTimeout(() => {
            document.getElementById('toss-screen').classList.add('hidden');
            startRound(rand);
        }, 500); 
    }

    function startRound(startPlayer) {
        currentPlayer = startPlayer;
        gameActive = true;
        moveHistory = []; 
        winningStones = []; 
        updateTurnUI();

        if (currentPlayer === AI) {
            setTimeout(makeAiMove, 1000);
        }
    }

    function undoLastTurn() {
        if (!gameActive || moveHistory.length === 0) return;
        if (currentPlayer === AI) return;

        let movesToUndo = 0;
        if (moveHistory.length > 0 && moveHistory[moveHistory.length-1].player === AI) {
            movesToUndo = 2; 
        } else {
            movesToUndo = 1; 
        }

        for (let i = 0; i < movesToUndo; i++) {
            if (moveHistory.length === 0) break;
            const last = moveHistory.pop();
            board[last.y][last.x] = 0;
        }

        currentPlayer = HUMAN;
        
        if (moveHistory.length > 0) {
            const prevMove = moveHistory[moveHistory.length - 1];
            if (prevMove.player === AI) {
                startBlinking(prevMove.x, prevMove.y);
            } else {
                if (blinkInterval) clearInterval(blinkInterval);
                lastMove = null;
            }
        } else {
            if (blinkInterval) clearInterval(blinkInterval);
            lastMove = null;
        }

        updateTurnUI();
        drawBoard();
    }


    canvas.addEventListener('click', (e) => {
        if (!gameActive || currentPlayer === AI || isDraggingOrZooming) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const clickX = (e.clientX - rect.left) * scaleX;
        const clickY = (e.clientY - rect.top) * scaleY;
        const gx = Math.round((clickX - PADDING) / CELL_SIZE);
        const gy = Math.round((clickY - PADDING) / CELL_SIZE);

        placeStone(gx, gy);
    });

    /* --- [í•µì‹¬] 3-3 ê¸ˆìˆ˜ ì²´í¬ ë¡œì§ --- */
    function checkForbidden33(x, y, player) {
        // ì¼ë‹¨ ëŒì„ ê°€ìƒìœ¼ë¡œ ë†“ëŠ”ë‹¤
        board[y][x] = player;
        
        // ì—´ë¦° 3ì˜ ê°œìˆ˜
        let open3Count = 0;
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

        for (let [dx, dy] of directions) {
            if (isOpenThree(x, y, dx, dy, player)) {
                open3Count++;
            }
        }

        // 5ëª© ì™„ì„± ì—¬ë¶€ í™•ì¸ (ìŠ¹ë¦¬ê°€ ê¸ˆìˆ˜ë³´ë‹¤ ìš°ì„ )
        let isWin = false;
        if (checkWinLine(x, y, player)) isWin = true;

        // ëŒì„ ë‹¤ì‹œ ì¹˜ìš´ë‹¤
        board[y][x] = 0;

        // ìŠ¹ë¦¬ ìë¦¬ë¼ë©´ 3-3ì´ì–´ë„ í—ˆìš©
        if (isWin) return false;

        // ì—´ë¦° 3ì´ 2ê°œ ì´ìƒì´ë©´ ê¸ˆìˆ˜
        return open3Count >= 2;
    }

    // ì—´ë¦° 3ì¸ì§€ íŒë³„í•˜ëŠ” í•¨ìˆ˜ (íŒ¨í„´ ë¶„ì„)
    function isOpenThree(x, y, dx, dy, player) {
        // ë¼ì¸ì„ ë¬¸ìì—´ë¡œ ì¶”ì¶œ (ë²”ìœ„ 4ì¹¸)
        // 0:ë¹ˆê³³, P:ë‚´ëŒ, M:ì§€ê¸ˆë†“ì€ëŒ, E:ìƒëŒ€ëŒ/ë²½
        let str = "";
        for (let i = -4; i <= 4; i++) {
            if (i === 0) str += "M"; 
            else {
                const nx = x + dx * i;
                const ny = y + dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
                    str += "E"; // ë²½ë„ ì ê³¼ ê°™ìŒ
                } else {
                    const cell = board[ny][nx];
                    if (cell === player) str += "P";
                    else if (cell === 0) str += "0";
                    else str += "E";
                }
            }
        }

        // ì—´ë¦° 3 íŒ¨í„´ ì •ê·œì‹ (ì–‘ìª½ì´ ëš«ë ¤ìˆê³  ëŒì´ 3ê°œì¸ ê²½ìš°)
        // 0PP M 0  or 0M PP 0 (ì—°ì† 3)
        // 0P M P 0 (ë–¨ì–´ì§„ 3)
        // ì£¼ì˜: 00PMP00 ë“±ë„ í¬í•¨ë¨. í•µì‹¬ì€ 'ë§‰íˆì§€ ì•Šì€ 3'
        
        // 1. ìŠ¤íŠ¸ë ˆì´íŠ¸ 3: 0PP M 0, 0M PP 0
        if (/0P{2}M0|0MP{2}0/.test(str)) return true;
        
        // 2. ì§•ê²€ë‹¤ë¦¬ 3: 0P M P0
        if (/0PMP0/.test(str)) return true;

        return false;
    }

    function showWarning(msg) {
        warningToast.innerText = msg;
        warningToast.classList.add('show');
        setTimeout(() => {
            warningToast.classList.remove('show');
        }, 1500);
    }

    /* --- AI ë¡œì§ --- */
    function makeAiMove() {
        if (!gameActive) return;
        let bestMove = getBestMove(AI);
        if (bestMove) {
            placeStone(bestMove.x, bestMove.y);
        }
    }

    function getBestMove(player) {
        // [ê·œì¹™ 1] AI ì„ ê³µ ì‹œ ì²« ìˆ˜ëŠ” ì²œì›
        if (moveHistory.length === 0) {
            const center = Math.floor(GRID_SIZE / 2);
            return {x: center, y: center};
        }

        const opponent = player === AI ? HUMAN : AI;
        let bestScore = -Infinity;
        let bestMoves = [];

        // ìƒëŒ€ë°©ì˜ ë§ˆì§€ë§‰ ìˆ˜
        let lastOpponentMove = null;
        if (moveHistory.length > 0) {
            lastOpponentMove = moveHistory[moveHistory.length - 1];
        }

        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (board[y][x] === 0) {
                    
                    // [ì¤‘ìš”] 3-3 ê¸ˆìˆ˜ ìë¦¬ëŠ” ì ˆëŒ€ ë‘ì§€ ì•ŠìŒ (AIë„ ê·œì¹™ ì¤€ìˆ˜)
                    if (checkForbidden33(x, y, player)) continue;

                    let attackScore = evaluatePoint(x, y, player); 
                    let defenseScore = evaluatePoint(x, y, opponent); 
                    
                    let totalScore = 0;
                    
                    if (attackScore >= 100000) totalScore = 10000000; 
                    else if (defenseScore >= 100000) totalScore = 5000000;
                    else {
                        totalScore = (attackScore * 1.5) + defenseScore;
                    }

                    if (attackScore < 100 && defenseScore < 100) {
                        const center = GRID_SIZE / 2;
                        const distFromCenter = Math.abs(x - center) + Math.abs(y - center);
                        totalScore += (20 - distFromCenter) * 0.5;

                        if (lastOpponentMove) {
                            const distFromLast = Math.abs(x - lastOpponentMove.x) + Math.abs(y - lastOpponentMove.y);
                            if (distFromLast <= 2) totalScore += 15; 
                            else if (distFromLast <= 4) totalScore += 5; 
                        }
                    }

                    totalScore += Math.random() * 2;

                    if (totalScore > bestScore) {
                        bestScore = totalScore;
                        bestMoves = [{x, y}];
                    } else if (Math.abs(totalScore - bestScore) < 1) { 
                        bestMoves.push({x, y});
                    }
                }
            }
        }
        
        return bestMoves.length > 0 ? bestMoves[Math.floor(Math.random() * bestMoves.length)] : null;
    }

    function evaluatePoint(x, y, player) {
        let score = 0;
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]]; 

        for (let [dx, dy] of directions) {
            if (!hasPotential(x, y, dx, dy, player)) continue;
            const lineStr = getLinePatternForScore(x, y, dx, dy, player);
            score += getPatternScore(lineStr);
        }
        return score;
    }

    function hasPotential(x, y, dx, dy, player) {
        let count = 1; 
        let i = 1;
        while(true) {
            let nx = x + dx * i, ny = y + dy * i;
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break; 
            if (board[ny][nx] !== 0 && board[ny][nx] !== player) break; 
            count++; i++;
        }
        let j = 1;
        while(true) {
            let nx = x - dx * j, ny = y - dy * j;
            if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
            if (board[ny][nx] !== 0 && board[ny][nx] !== player) break; 
            count++; j++;
        }
        return count >= 5;
    }

    function getLinePatternForScore(x, y, dx, dy, player) {
        let str = "";
        for (let i = -4; i <= 4; i++) {
            if (i === 0) {
                str += "M"; 
            } else {
                const nx = x + dx * i;
                const ny = y + dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
                    str += "X"; 
                } else {
                    const cell = board[ny][nx];
                    if (cell === player) str += "P"; 
                    else if (cell === 0) str += "0"; 
                    else str += "E"; 
                }
            }
        }
        return str;
    }

    function getPatternScore(str) {
        if (/P{4}M|MP{4}|P{3}MP|PMP{3}|P{2}MP{2}/.test(str)) return 100000;
        if (/0P{3}M0|0MP{3}0|0P{2}MP0|0PMP{2}0/.test(str)) return 50000;
        if (/P{3}M|MP{3}|P{2}MP|PMP{2}/.test(str)) return 5000; 
        if (/0P{2}M0|0MP{2}0|0PMP0/.test(str)) return 10000;
        if (/P{2}0MP|PM0P{2}|P0PMP|PMP0P/.test(str)) return 4000; 
        if (/00PM00|00MP00|0P0M0/.test(str)) return 1000;
        return 0;
    }

    function placeStone(x, y) {
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;
        if (board[y][x] !== 0) return;

        // [3-3 ê¸ˆìˆ˜ ì²´í¬ ì ìš©]
        if (checkForbidden33(x, y, currentPlayer)) {
            // ê¸ˆìˆ˜ì´ë©´ ê²½ê³  í‘œì‹œí•˜ê³  ì°©ìˆ˜ ì·¨ì†Œ
            showWarning("ğŸš« 3-3 ê¸ˆìˆ˜ì…ë‹ˆë‹¤!");
            // ì‚‘ ì†Œë¦¬(ì˜¤ë¥˜ìŒ) ëŒ€ì‹  ê°€ë²¼ìš´ ì§„ë™(ëª¨ë°”ì¼)
            if(navigator.vibrate) navigator.vibrate(200);
            return;
        }

        if (currentPlayer === HUMAN) {
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
            }
            lastMove = null; 
        }

        board[y][x] = currentPlayer;
        
        moveHistory.push({x: x, y: y, player: currentPlayer});
        
        if (currentPlayer === HUMAN) playSound(sndBlack);
        else playSound(sndWhite);

        if (currentPlayer === AI) {
            startBlinking(x, y);
        }

        drawBoard(); 

        const winLine = checkWinLine(x, y, currentPlayer);
        
        if (winLine) {
            handleWinWithAnimation(currentPlayer, winLine);
        } else {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnUI();
            if (gameActive && currentPlayer === AI) {
                setTimeout(makeAiMove, 1000); 
            }
        }
    }

    function checkWinLine(x, y, player) {
        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

        for (let [dx, dy] of directions) {
            let line = [{x, y}];

            let i = 1;
            while(true) {
                const nx = x + dx * i;
                const ny = y + dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE || board[ny][nx] !== player) break;
                line.push({x: nx, y: ny});
                i++;
            }

            let j = 1;
            while(true) {
                const nx = x - dx * j;
                const ny = y - dy * j;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE || board[ny][nx] !== player) break;
                line.push({x: nx, y: ny});
                j++;
            }

            if (line.length === 5) return line;
        }
        return null;
    }

    function handleWinWithAnimation(winner, winLine) {
        gameActive = false;
        winningStones = winLine; 
        
        let toggle = true;
        winBlinkState = true;
        
        if(winBlinkInterval) clearInterval(winBlinkInterval);
        winBlinkInterval = setInterval(() => {
            winBlinkState = !winBlinkState;
            drawBoard();
        }, 200);

        setTimeout(() => {
            clearInterval(winBlinkInterval);
            winBlinkState = true; 
            drawBoard();
            
            finishGame(winner);
        }, 5000);
    }

    function finishGame(winner) {
        scores[winner]++;
        winnerOfLastRound = winner;
        
        document.getElementById(`score-p${winner}`).innerText = `${scores[winner]} ìŠ¹`;

        if (scores[winner] >= 2) {
            playSound(sndFinalWin);

            const finalScreen = document.getElementById('final-win-screen');
            const finalImg = document.getElementById('final-win-img'); 
            const finalText = document.getElementById('final-win-text');
            
            if (winner === HUMAN) {
                finalImg.src = 'ggam_win.png';
                finalText.innerText = "ë‚´ê°€ ì´ê²¼ì–´ ì–´ì©”ë˜!!!";
            } else {
                finalImg.src = 'kimchi_win.png';
                finalText.innerText = "ê¹€ì¹˜ê°€ ì´ê²¼ì–´! í›—^^";
            }

            finalScreen.classList.remove('hidden');

            setTimeout(() => {
                finalScreen.classList.add('hidden');
                location.reload();
            }, 5000); 

        } else {
            playSound(sndRoundWin);

            const screen = document.getElementById('ceremony-screen');
            const img = document.getElementById('ceremony-img');
            const txt = document.getElementById('ceremony-text');

            screen.classList.remove('hidden');
            
            if (winner === HUMAN) { 
                img.src = 'ggam-5.png'; 
                txt.innerText = "ì•„ì‹¸!";
            } else { 
                img.src = 'kimchi-o2.png'; 
                txt.innerText = "í›—, ë‹¹ì—°í•˜ì§€!";
            }

            setTimeout(() => {
                screen.classList.add('hidden');
                round++;
                resetBoard();
                showCoinToss(); 
            }, 3000);
        }
    }

    function resetBoard() {
        if (blinkInterval) clearInterval(blinkInterval);
        if (winBlinkInterval) clearInterval(winBlinkInterval);
        
        lastMove = null;
        winningStones = [];
        moveHistory = []; 

        board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        drawBoard();
    }

    /* --- í•€ì¹˜ ì¤Œ & íŒ¬ ë¡œì§ --- */
    let currentScale = 1;
    let currentX = 0;
    let currentY = 0;
    let startX = 0;
    let startY = 0;
    let startDist = 0;
    let startScale = 1;
    let isDraggingOrZooming = false; 
    let lastTapTime = 0;

    boardContainer.addEventListener('touchstart', handleTouchStart, {passive: false});
    boardContainer.addEventListener('touchmove', handleTouchMove, {passive: false});
    boardContainer.addEventListener('touchend', handleTouchEnd, {passive: false});

    function handleTouchStart(e) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;
        if (tapLength < 300 && tapLength > 0 && e.touches.length === 1) {
            resetZoom();
            e.preventDefault();
            return;
        }
        lastTapTime = currentTime;

        isDraggingOrZooming = false;

        if (e.touches.length === 2) {
            startDist = getDistance(e.touches);
            startScale = currentScale;
        } else if (e.touches.length === 1) {
            startX = e.touches[0].clientX - currentX;
            startY = e.touches[0].clientY - currentY;
        }
    }

    function handleTouchMove(e) {
        e.preventDefault(); 
        isDraggingOrZooming = true; 

        if (e.touches.length === 2) {
            const dist = getDistance(e.touches);
            const scaleFactor = dist / startDist;
            let newScale = startScale * scaleFactor;
            newScale = Math.max(1, Math.min(newScale, 3));
            currentScale = newScale;
            clampPosition();
            updateTransform();
        } else if (e.touches.length === 1 && currentScale > 1) {
            const x = e.touches[0].clientX;
            const y = e.touches[0].clientY;
            currentX = x - startX;
            currentY = y - startY;
            clampPosition();
            updateTransform();
        }
    }

    function handleTouchEnd(e) {
        if (e.touches.length < 2) startDist = 0;
        if (e.touches.length === 1) {
            startX = e.touches[0].clientX - currentX;
            startY = e.touches[0].clientY - currentY;
        }
        setTimeout(() => { isDraggingOrZooming = false; }, 50);
    }

    function getDistance(touches) {
        return Math.hypot(
            touches[0].clientX - touches[1].clientX,
            touches[0].clientY - touches[1].clientY
        );
    }

    function clampPosition() {
        const boardW = zoomLayer.offsetWidth * currentScale;
        const boardH = zoomLayer.offsetHeight * currentScale;
        const containerW = boardContainer.offsetWidth;
        const containerH = boardContainer.offsetHeight;

        let maxTranslateX = 0;
        let maxTranslateY = 0;

        if (boardW > containerW) maxTranslateX = (boardW - containerW) / 2;
        if (boardH > containerH) maxTranslateY = (boardH - containerH) / 2;

        if (currentX > maxTranslateX) currentX = maxTranslateX;
        if (currentX < -maxTranslateX) currentX = -maxTranslateX;
        if (currentY > maxTranslateY) currentY = maxTranslateY;
        if (currentY < -maxTranslateY) currentY = -maxTranslateY;
    }

    function updateTransform() {
        zoomLayer.style.transform = `translate(${currentX}px, ${currentY}px) scale(${currentScale})`;
    }

    function resetZoom() {
        currentScale = 1;
        currentX = 0;
        currentY = 0;
        updateTransform();
    }

    initCanvas();
</script>
</body>
</html>