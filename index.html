<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>까미 vs 김치: 운명의 오목 한판</title>
    <meta property="og:type" content="website">
    <meta property="og:title" content="까미 vs 김치: 운명의 오목 한판">
    <meta property="og:description" content="흑(까미) vs 백(김치)! 과연 승자는?">
    <meta property="og:image" content="kakao.jpg">
    <link rel="icon" href="kakao.jpg">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gamja+Flower&display=swap" rel="stylesheet">

    <style>
        /* [1. 화면 강제 맞춤을 위한 기본 설정 (고스톱 게임 로직 이식)] */
        html, body {
            margin: 0; 
            padding: 0;
            width: 100%; 
            height: 100%;
            background-color: #222;
            overflow: hidden; /* 스크롤 방지 */
            position: fixed; 
            touch-action: none; 
            font-family: 'Gamja Flower', cursive;
            user-select: none;
            -webkit-user-select: none;
        }

        /* 게임 전체를 감싸는 래퍼 (중앙 정렬) */
        #game-wrapper {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            z-index: 1;
        }

        /* 실제 게임 컨테이너 (스케일링 대상) */
        .game-container {
            /* 기본 해상도 설정 (이 크기를 기준으로 확대/축소됨) */
            /* JS에서 가로/세로 모드에 따라 동적으로 width/height가 설정됩니다 */
            display: flex;
            background-color: #222;
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            transform-origin: center center; /* 중앙 기준 확대/축소 */
            flex-shrink: 0;
        }

        /* --- 기존 스타일 유지 --- */
        .player-frame {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; 
            padding: 20px;
            background: #333;
            box-sizing: border-box;
            transition: all 0.3s;
            position: relative;
            z-index: 10;
        }

        .player-top-info {
            display: flex;
            align-items: center;
            width: 100%;
            height: 60px; 
            justify-content: flex-start;
            flex-direction: row; 
            text-align: left;
        }

        .mini-profile-img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #fff;
            object-fit: cover;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            margin-right: 15px; 
        }

        .mini-player-name {
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            white-space: nowrap; /* 이름 줄바꿈 방지 */
        }

        .board-frame {
            flex: 2;
            position: relative;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border-left: 2px solid #555;
            border-right: 2px solid #555;
        }

        /* 카드 확대 효과 */
        .player-info-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            width: 100%;
            height: auto;
            padding: 10px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid transparent;
            margin-bottom: 0;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s;
            cursor: pointer;
            transform-origin: bottom center; 
        }

        .player-info-box:hover, .player-info-box:active {
            transform: scale(1.15); 
            z-index: 20;
            background: rgba(0, 0, 0, 0.6);
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
        }

        .full-body-img {
            width: 100%;
            max-height: 350px; 
            object-fit: contain;
            filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5));
            margin-bottom: 10px;
            pointer-events: none; 
        }

        .score-badge {
            background: #444;
            padding: 5px 20px;
            border-radius: 20px;
            font-size: 1.5rem;
            color: #ffd700;
            font-weight: bold;
            white-space: nowrap;
        }

        .active-turn .player-info-box {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: pulse-border 1.5s infinite;
        }
        
        .active-turn .player-info-box:hover, .active-turn .player-info-box:active {
             animation: none; 
             border-color: #fff;
        }

        @keyframes pulse-border {
            0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.7); }
            100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
        }

        #game-zoom-layer {
            position: relative;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }

        #go-board {
            background: url('wood.jpg') no-repeat center center;
            background-size: cover;
            border: 15px solid #000;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            display: block;
        }

        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        .yellow-btn {
            background-color: #ffd700;
            color: #000;
            font-family: 'Gamja Flower', cursive;
            font-size: 2.8rem;
            font-weight: bold;
            padding: 15px 50px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .yellow-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.6);
        }

        .coin-toss-btn {
            width: 150px; height: 150px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff, #ddd);
            border: 5px solid #ffd700;
            font-family: 'Gamja Flower', cursive;
            font-size: 2.2rem;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
            animation: float 2s infinite ease-in-out;
            overflow: hidden;
            color: #000;
            font-weight: bold;
        }
        
        .coin-toss-btn img { width: 100%; height: 100%; object-fit: cover; display: none; }

        .ceremony-content { text-align: center; animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .ceremony-img { max-width: 300px; max-height: 300px; filter: drop-shadow(0 0 20px rgba(255,255,255,0.5)); }
        .ceremony-text {
            font-size: 4.5rem; color: #ffd700;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            margin-top: 20px; font-family: 'Gamja Flower', cursive;
        }

        .final-win-img {
            max-width: 80%;
            max-height: 60vh;
            border-radius: 20px;
            border: 5px solid #ffd700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            margin-bottom: 20px;
        }

        .fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: #ffd700;
            color: #000;
            border: 3px solid #000;
            border-radius: 50%;
            cursor: pointer;
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            font-size: 2rem;
            transition: transform 0.2s, box-shadow 0.2s;
            outline: none;
        }
        
        .fullscreen-btn:active {
            transform: scale(0.9);
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }

        @keyframes popUp { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        /* --- 모바일 반응형 (내부 배치만 담당) --- */
        @media (max-width: 768px) {
            .game-container { flex-direction: column; }
            
            .player-frame { 
                flex-direction: row; 
                flex: 0 0 80px; /* 고정 높이 */
                padding: 5px 10px; 
            }
            
            .mini-player-name { font-size: 1.5rem; }
            .mini-profile-img { width: 40px; height: 40px; }
            
            .player-info-box { 
                width: auto; 
                padding: 5px; 
                flex-direction: row; 
                transform-origin: center;
            }
            .player-info-box:hover, .player-info-box:active {
                transform: scale(1.1); 
            }

            .full-body-img { display: none; } 
            
            .board-frame { flex: 1; border: none; }
            #go-board { border-width: 5px; }
            
            .fullscreen-btn {
                bottom: 10px;
                right: 10px;
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
                opacity: 0.9; 
            }
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div class="game-container">
        <div class="player-frame left" id="frame-p1">
            <div class="player-top-info">
                <img src="black_ggami.png" class="mini-profile-img">
                <div class="mini-player-name">까미 (나)</div>
            </div>
            <div class="player-info-box">
                <img src="ggami_2.png" class="full-body-img">
                <div class="score-badge" id="score-p1">0 승</div>
            </div>
        </div>

        <div class="board-frame" id="board-container">
            <div id="game-zoom-layer">
                <canvas id="go-board" width="600" height="600"></canvas>
            </div>

            <div id="start-screen" class="overlay-screen">
                <h1 style="font-size: 5rem; margin-bottom: 20px;">까미 vs 김치</h1>
                <button class="yellow-btn" onclick="showCoinToss()">게임 시작</button>
            </div>

            <div id="toss-screen" class="overlay-screen hidden">
                <h2 style="margin-bottom: 30px; font-size: 3.5rem;">운명의 선택</h2>
                <div class="coin-toss-btn" id="coin-btn" onclick="decideFirstTurn()">
                    <span>터치!</span>
                    <img id="toss-result-img" src="">
                </div>
                <p id="toss-msg" style="margin-top: 20px; font-size: 1.8rem;">터치해서 선공을 정하세요!</p>
            </div>

            <div id="ceremony-screen" class="overlay-screen hidden">
                <div class="ceremony-content">
                    <img id="ceremony-img" src="" class="ceremony-img">
                    <div id="ceremony-text" class="ceremony-text"></div>
                </div>
            </div>

            <div id="final-win-screen" class="overlay-screen hidden">
                <div class="ceremony-content">
                    <img src="sangkim.png" class="final-win-img">
                    <div id="final-win-text" class="ceremony-text"></div>
                </div>
            </div>
            
            <button class="fullscreen-btn" onclick="toggleFullscreenAndReset()" title="화면 채움 / 리셋">
                ⛶
            </button>
        </div>

        <div class="player-frame right" id="frame-p2">
            <div class="player-top-info">
                <img src="white_kimchi.png" class="mini-profile-img">
                <div class="mini-player-name">김치 (AI)</div>
            </div>
            <div class="player-info-box">
                <img src="kimchi_3.png" class="full-body-img">
                <div class="score-badge" id="score-p2">0 승</div>
            </div>
        </div>
    </div>
</div>

<script>
    /* --- 변수 설정 --- */
    const canvas = document.getElementById('go-board');
    const ctx = canvas.getContext('2d');
    const zoomLayer = document.getElementById('game-zoom-layer');
    
    const GRID_SIZE = 15;
    const CELL_SIZE = 40;
    const PADDING = 20;
    const BOARD_PIXEL_SIZE = CELL_SIZE * (GRID_SIZE - 1) + PADDING * 2;

    const HUMAN = 1; 
    const AI = 2;    

    let board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
    let currentPlayer = 1;
    let gameActive = false;
    let round = 1;
    let scores = { 1: 0, 2: 0 };
    let winnerOfLastRound = 0;

    const imgBlack = new Image(); imgBlack.src = 'black_ggami.png';
    const imgWhite = new Image(); imgWhite.src = 'white_kimchi.png';
    
    // --- 사운드 객체 ---
    const sndStart = new Audio('start.mp3');
    const sndBlack = new Audio('clack.mp3');
    const sndWhite = new Audio('clack_1.mp3');
    const sndRoundWin = new Audio('winbrass.mp3');
    const sndFinalWin = new Audio('fanfare.mp3');

    function playSound(audio) {
        audio.currentTime = 0; 
        audio.play().catch(e => console.log('Sound play blocked', e));
    }

    let scale = 1;
    let panX = 0; let panY = 0;
    let lastTouchX = 0; let lastTouchY = 0; let lastDist = 0;

    /* ---------------------------------------------------
       [화면 강제 맞춤 로직 (Gostop 게임에서 이식)]
       --------------------------------------------------- */
    function resizeGame() {
        const container = document.querySelector('.game-container');
        const winW = window.innerWidth;
        const winH = window.innerHeight;

        // 가로/세로 모드 감지하여 기준 해상도(Target Size) 변경
        // 이렇게 해야 내부 CSS (@media max-width:768px)가 올바르게 작동함
        const isPortrait = winH > winW;
        
        let targetW, targetH;
        
        if (isPortrait) {
            // 세로 모드 (모바일) 기준 해상도 설정
            // 720px로 설정하여 CSS의 @media (max-width: 768px)가 발동되게 함
            targetW = 720; 
            targetH = 1280; 
        } else {
            // 가로 모드 (PC/태블릿) 기준 해상도 설정
            targetW = 1600; 
            targetH = 900; 
        }

        // 컨테이너 크기 강제 설정
        container.style.width = targetW + 'px';
        container.style.height = targetH + 'px';

        // 윈도우 크기에 맞춰 스케일 계산 (비율 유지)
        const scale = Math.min(winW / targetW, winH / targetH);
        
        // 스케일 적용
        container.style.transform = `scale(${scale})`;
    }

    // 리사이즈 이벤트 리스너 등록
    window.addEventListener('resize', resizeGame);
    window.addEventListener('orientationchange', () => { setTimeout(resizeGame, 200); });
    window.onload = () => {
        resizeGame();
        initCanvas();
    };

    /* --------------------------------------------------- */

    function initCanvas() {
        canvas.width = BOARD_PIXEL_SIZE;
        canvas.height = BOARD_PIXEL_SIZE;
        drawBoard();
    }

    imgBlack.onload = drawBoard;
    imgWhite.onload = drawBoard;

    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        for (let i = 0; i < GRID_SIZE; i++) {
            ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
            ctx.lineTo(PADDING + (GRID_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE);
            ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
            ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (GRID_SIZE - 1) * CELL_SIZE);
        }
        ctx.stroke();
        const stars = [3, 7, 11];
        ctx.fillStyle = "#000";
        for (let r of stars) {
            for (let c of stars) {
                ctx.beginPath();
                ctx.arc(PADDING + r * CELL_SIZE, PADDING + c * CELL_SIZE, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (board[y][x] > 0) drawStone(x, y, board[y][x]);
            }
        }
    }

    function drawStone(x, y, player) {
        const cx = PADDING + x * CELL_SIZE;
        const cy = PADDING + y * CELL_SIZE;
        const radius = CELL_SIZE / 2 - 2;
        const img = player === 1 ? imgBlack : imgWhite;
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.clip();
        ctx.drawImage(img, cx - radius, cy - radius, radius * 2, radius * 2);
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.stroke();
        ctx.restore();
    }

    function updateTurnUI() {
        document.getElementById('frame-p1').classList.toggle('active-turn', currentPlayer === HUMAN);
        document.getElementById('frame-p2').classList.toggle('active-turn', currentPlayer === AI);
    }

    function showCoinToss() {
        document.getElementById('start-screen').classList.add('hidden');
        if (round === 1) document.getElementById('toss-screen').classList.remove('hidden');
        else {
            playSound(sndStart); 
            startRound(winnerOfLastRound || 1);
        }
    }

    function decideFirstTurn() {
        const rand = Math.floor(Math.random() * 2) + 1;
        document.getElementById('toss-result-img').src = rand === 1 ? 'black_ggami.png' : 'white_kimchi.png';
        document.getElementById('toss-result-img').style.display = 'block';
        document.querySelector('#coin-btn span').style.display = 'none';
        document.getElementById('toss-msg').innerText = `${rand === 1 ? '까미(나)' : '김치(AI)'} 선공!`;
        
        setTimeout(() => {
            document.getElementById('toss-screen').classList.add('hidden');
            playSound(sndStart);
            startRound(rand);
        }, 1000);
    }

    function startRound(startPlayer) {
        currentPlayer = startPlayer;
        gameActive = true;
        updateTurnUI();
        if (currentPlayer === AI) setTimeout(makeAiMove, 1000);
    }

    canvas.addEventListener('click', (e) => {
        if (!gameActive || currentPlayer === AI) return;
        
        // getBoundingClientRect는 transform된 크기를 반환하므로 좌표 계산은 그대로 유지 가능
        const rect = canvas.getBoundingClientRect();
        const gx = Math.round(((e.clientX - rect.left) * (canvas.width / rect.width) - PADDING) / CELL_SIZE);
        const gy = Math.round(((e.clientY - rect.top) * (canvas.height / rect.height) - PADDING) / CELL_SIZE);
        placeStone(gx, gy);
    });

    // --- AI 알고리즘 ---
    function makeAiMove() {
        if (!gameActive) return;
        let bestScore = -Infinity, bestMoves = [];
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (board[y][x] === 0) {
                    let aScore = evaluatePoint(x, y, AI), dScore = evaluatePoint(x, y, HUMAN);
                    let total = aScore + (dScore * 1.2) + Math.random() * 5;
                    if (aScore >= 100000) total = 2000000;
                    else if (dScore >= 100000) total = 1000000;
                    if (total > bestScore) { bestScore = total; bestMoves = [{x, y}]; }
                    else if (total === bestScore) bestMoves.push({x, y});
                }
            }
        }
        let move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
        if (move) placeStone(move.x, move.y);
    }

    function evaluatePoint(x, y, player) {
        let score = 0;
        const dirs = [[1, 0], [0, 1], [1, 1], [1, -1]];
        for (let [dx, dy] of dirs) {
            let str = "";
            for (let i = -4; i <= 4; i++) {
                if (i === 0) str += "M";
                else {
                    let nx = x + dx * i, ny = y + dy * i;
                    if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) str += "X";
                    else if (board[ny][nx] === player) str += "P";
                    else if (board[ny][nx] === 0) str += "0";
                    else str += "E";
                }
            }
            if (/P{4}M|MP{4}|P{3}MP|PMP{3}|P{2}MP{2}/.test(str)) score += 100000;
            else if (/0P{3}M0|0MP{3}0|0P{2}MP0|0PMP{2}0/.test(str)) score += 50000;
            else if (/P{3}M|MP{3}|P{2}MP|PMP{2}/.test(str)) score += 10000;
            else if (/P{2}0MP|PM0P{2}|P0PMP|PMP0P/.test(str)) score += 8000;
            else if (/0P{2}M0|0MP{2}0|0PMP0/.test(str)) score += 5000;
            else if (/0P0PM0|0MP0P0|0P0MP0/.test(str)) score += 4500;
        }
        return score;
    }

    function check33(x, y, player) {
        board[y][x] = player;
        let count = 0;
        [[1,0], [0,1], [1,1], [1,-1]].forEach(([dx, dy]) => {
            let str = "";
            for (let i = -4; i <= 4; i++) {
                let nx = x + dx * i, ny = y + dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) str += "X";
                else str += (board[ny][nx] === player ? "P" : (board[ny][nx] === 0 ? "0" : "E"));
            }
            if (str.includes("0PPP0") || str.includes("0P0PP0") || str.includes("0PP0P0")) count++;
        });
        board[y][x] = 0;
        return count >= 2;
    }

    function placeStone(x, y) {
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE || board[y][x] !== 0) return;
        if (currentPlayer === HUMAN && check33(x, y, HUMAN)) { alert("3-3 금수입니다!"); return; }
        
        board[y][x] = currentPlayer;
        
        if (currentPlayer === HUMAN) playSound(sndBlack);
        else playSound(sndWhite);

        drawBoard();
        if (checkWin(x, y, currentPlayer)) handleWin(currentPlayer);
        else { currentPlayer = currentPlayer === 1 ? 2 : 1; updateTurnUI(); if (gameActive && currentPlayer === AI) setTimeout(makeAiMove, 1000); }
    }

    function checkWin(x, y, p) {
        return [[1,0],[0,1],[1,1],[1,-1]].some(([dx,dy]) => {
            let count = 1;
            for (let i=1; i<5; i++) { let nx=x+dx*i, ny=y+dy*i; if (nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE && board[ny][nx]===p) count++; else break; }
            for (let i=1; i<5; i++) { let nx=x-dx*i, ny=y-dy*i; if (nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE && board[ny][nx]===p) count++; else break; }
            return count >= 5;
        });
    }

    function handleWin(w) {
        gameActive = false; scores[w]++; winnerOfLastRound = w;
        document.getElementById(`score-p${w}`).innerText = `${scores[w]} 승`;
        
        if (scores[w] >= 2) {
            playSound(sndFinalWin);
            document.getElementById('final-win-text').innerText = `${w===1?'까미':'김치'} 최종 우승!`;
            document.getElementById('final-win-screen').classList.remove('hidden');
            setTimeout(() => location.reload(), 4000);
        } else {
            playSound(sndRoundWin);
            document.getElementById('ceremony-img').src = w===1 ? 'ggam-5.png' : 'kimchi-o2.png';
            document.getElementById('ceremony-text').innerText = w===1 ? "아싸!" : "훗, 당연하지!";
            document.getElementById('ceremony-screen').classList.remove('hidden');
            setTimeout(() => { document.getElementById('ceremony-screen').classList.add('hidden'); round++; resetBoard(); showCoinToss(); }, 3000);
        }
    }

    function resetBoard() { board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)); drawBoard(); }

    /* --- 줌 & 팬 로직 --- */
    const containerEl = document.getElementById('board-container'); // 보드 프레임 기준
    containerEl.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) { lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); }
        else { lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY; }
    }, {passive: false});

    containerEl.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 2) {
            let dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            scale = Math.max(1, Math.min(scale * (dist / lastDist), 3));
            lastDist = dist;
        } else if (scale > 1) {
            panX += (e.touches[0].clientX - lastTouchX); panY += (e.touches[0].clientY - lastTouchY);
            lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
            let limit = (scale - 1) * (BOARD_PIXEL_SIZE / 2);
            panX = Math.max(-limit, Math.min(limit, panX)); panY = Math.max(-limit, Math.min(limit, panY));
        }
        zoomLayer.style.transform = `scale(${scale}) translate(${panX / scale}px, ${panY / scale}px)`;
    }, {passive: false});

    function toggleFullscreenAndReset() {
        if (scale > 1) { 
            scale = 1; panX = 0; panY = 0; 
            zoomLayer.style.transform = `scale(1) translate(0,0)`; 
            return; 
        }
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(e => console.log(e));
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    }
</script>
</body>
</html>